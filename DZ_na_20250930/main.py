
print()
print("Напишите программу, которая:\n" \
"- Принимает текст от пользователя.\n" \
"- Подсчитывает количество слов.\n" \
"- Находит самое длинное слово.\n" \
"- Подсчитывает количество предложений (разделенных точками).")
print()

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# Находим:
# - количество слов в заданном тексте,
# - самое длинное слово в заданном тексте.

# Просим пользователя ввести в текст и сохраняем этот текст в переменную.
user_text = input("Введите текст: ")

# Полученный текст разбиваем по пробелам и сохраняем в список "list_words".
list_words = user_text.split()
# Проверяем, какие элементы сохранились в список "list_words".
# print("list_words = ", list_words)

'''

При вводе текста пользователь может ошибиться и поставить пробел 
между словом и знаком препинания. В таком случае система вынесет этот знак препинания
в отдельный элемент и при подсчете элементов тоже его посчитает.
Нам же нужно посчитать только слова. Для этого нам нужно очистить список от таких случайных
одиноких знаков препинания. 
Для этого мы создадим:
- список, в котором перечислим все знаки препинания, которые можем предусмотреть, что они могут быть использованы пользователем в его тексте,
также в этот список добавим значение "" на случай, если в списке окажется пустая строка,
- новый пустой список, в который сохраним все, кроме одиночных знаков препинания.

'''

# Создаем список, в котором перечисляем символы, которые, как предполагаем, пользователь
# может использовать в своем тексте.
# В этом списке перечислены только основные варианты символов.
symbols = ["!", "$", "(", ")", "-", "_", "=", "+", "{", "}", "[", "]", "'", ",", ".", ":", "*", "?", '"', "<", ">", ";", ""]

# Создаем новый пустой список, в который сохраним все, кроме одиночных знаков препинания.
list_words_2 = []

# Выполняем перебор элементов, проверяем, является ли этот элемент одиночным знаком препинания,
# то есть, входит ли он в список "symbols",
# если нет, то добавляем его в новый список "list_words_2".
for i in list_words:
    if i not in symbols:
        list_words_2.append(i)

# Проверяем, какие элементы сохранились в список "list_words_2".
# print("list_words_2 = ", list_words_2)


'''
Поскольку split() делит по пробелам, то если пользователь после слов будет вводить знаки препинания, 
то они будут считаться символами строк и при подсчете будут "восприниматься" системой как будто это буквы.
Нам же нужно, чтобы в подсчет входили только буквы.
Для этого выполним перебор всех элементов из списка "list_words", у тех элементов, 
у которых есть знаки препинания в конце, удалим эти знаки препинания,
и уже "очищенные" подстроки занесем в новый список.

'''

# Создаем новый пустой список, в который после перебора
# элементов из списка "list_words_2" и удаления из конца их знаков препинания
# будем сохранять эти уже "очищенные" элементы.
list_words_3 = []

# Выполняем перебор элементов из списка "list_words_2", "очищаем" их от знаков препинания в конце
# и сохраняем "очищенные" элементы в новый список "list_words_3".
for i in list_words_2:
    if i[-1] in symbols:
        # Для удаления ненужного последнего элемента в подстроке
        # ипользуем срез от начала до препоследнего символа.
        # То есть, используем срез - [:-1].
        list_words_3.append(i[:-1])
    else:
        list_words_3.append(i)

# Проверяем, что сохранилось в новый список "list_words_3".
# print("list_words_3 = ", list_words_3)

# Создаем новый пустой список, в который будем сохранять только те подстроки,
# которые содержат только буквы.
list_words_4 = []

# Выполняем перебор элементов из списка "list_words_3"
# и сохраняем в список "list_words_3" только те элементы,
# которые состоят из букв.
for i in list_words_3:
    # Проверяем, что элемент из списка "list_words_3" состоит только из букв.
    # Для этого используем метод "isalpha()".
    if i.isalpha():
        list_words_4.append(i)

# Проверяем, что сохранилось в новый список "list_words_4".
# print("list_words_4 = ", list_words_4)

'''

Поскольку нам нужно найти самое длинное слово в заданном тексте,
выполним следующие действия:
- создадим переменную "longest_word" с пустым значением, в нее будем сохранять нужные результата от перебора 
элементов в списке "list_words_4",
- выполним перебор, в котором будем сравнивать длину элемента из списка "list_words_4"
с длиной переменной "longest_word" и если длина элемента из списка "list_words_4" будет больше,
чем длина переменной "longest_word", то этот элемент будем сохранять в переменную "longest_word".
В результате этих действий в переменной "longest_word" останется только самое длинное слово.

'''
longest_word = ""

for i in list_words_4:
    if len(i) > len(longest_word):
        longest_word = i

print()
print(f"Вы ввели текст: {user_text}")
print(f"Количество слов в этом тексте - {len(list_words_4)}")

print(f"Самое длинное слово в этом тексте - {longest_word}.")

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# Высчитываем количество предложений в тексте.

'''

Далее нужно найти, сколько предложений находится в заднном тексте.
Для этого выполним следующие действия:
- сохраним в переменную результат разбиения заданного текста по знаку ".",
- удалим из этого списка пустые строки,
- подсчитаем количество элементов в новом списке количество элементов - это и будет количество предложений в заданном тексте.

'''
# Сохраняем в переменную "list_sentence" результат разбиения заданного текста по знаку ".".
list_sentence = user_text.split(".")

# Проверяем, какие элементы сохранились в переменную "list_sentence".
# print("list_sentence = ", list_sentence)

'''
Поскольку split разбивает строку на подстроки, которые есть ДО разделителя и ПОСЛЕ разделителя - 
а после последнего разделителя, как правило, ничего нет, 
то в списке последняя строка будет пустой.

То есть, если сделать так:
print("??".split("?"))
то получится три пустые строки - ['', '', ''], 
потому что:
"[тут пусто]?[тут пусто]?[тут пусто]"

Для того, чтобы в нашем списке избавиться от последней (пустой) строки, выполним перебор этого списка и добавим нужные результаты
в новый список.

'''
# Создаем новый пустой список, в который будем складывать результат перебора элементов из списка "list_sentence".
list_sentence_2 = []

# Выполняем перебор элементов из списка "list_sentence" и сохраняем нужные результаты в новый список.
# В этом переборе задано условие, что если элемент из списка "list_sentence" пустой, то он не сохраняется в новый список.
for i in list_sentence:
    if len(i) != 0:
        list_sentence_2.append(i)

# Проверяем, какие элементы сохранились в список "list_sentence_2".
# print("list_sentence_2 = ", list_sentence_2)

print(f"Количество предложений в этом тексте - {len(list_sentence_2)}")
print()
